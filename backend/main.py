from __future__ import annotations

from typing import Any, Dict, Optional
from uuid import uuid4

from fastapi import Depends, FastAPI, HTTPException, Path
from fastapi.middleware.cors import CORSMiddleware
from langchain_core.messages import HumanMessage
from sqlalchemy.exc import NoResultFound
from sqlmodel import Session, select

from config import get_settings
from db import get_session, init_db
from graph import GraphConfig, build_graph
from models import EmailDirection, NegotiationStatus, NegotiationThread, EmailLog
from schemas import EmailPayload, NegotiationState


settings = get_settings()
graph_app = build_graph()

app = FastAPI(title="Vendor AI", version="0.1.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.on_event("startup")
def on_startup() -> None:
    """Initialise database schema on application startup."""
    init_db()


def _build_initial_state(email: EmailPayload, thread_id: str) -> NegotiationState:
    """Construct the initial LangGraph state from an inbound email."""
    user_message = HumanMessage(
        content=(
            f"New vendor SaaS pricing email.\n\n"
            f"From: {email.from_email}\n"
            f"To: {email.to_email}\n"
            f"Subject: {email.subject}\n\n"
            f"Body:\n{email.body_text}"
        ),
    )

    state: NegotiationState = {
        "messages": [user_message],
        "current_offer": None,
        "target_price": None,
        "status": "pending_analysis",
        "vendor_name": None,
        "product_name": None,
        "sender_name": None,
        "recipient_name": None,
        "thread_id": thread_id,
        "draft_response": None,
    }
    return state


def _invoke_graph(
    state: NegotiationState,
    thread_id: str,
) -> NegotiationState:
    """Invoke the LangGraph negotiation app until the human-review interrupt."""
    config: GraphConfig = {"configurable": {"thread_id": thread_id}}
    result = graph_app.invoke(state, config=config)
    return result


@app.post("/webhook/email")
def webhook_email(
    payload: EmailPayload,
    session: Session = Depends(get_session),
) -> Dict[str, Any]:
    """Receive an inbound vendor email and trigger the negotiation agent.

    This endpoint:
    - Persists a new `NegotiationThread` and inbound `EmailLog`.
    - Starts a new LangGraph run for a fresh `thread_id`.
    - Executes until the human-review interrupt is hit.
    - Returns the draft email and current negotiation status.
    """
    thread_id = str(uuid4())

    negotiation = NegotiationThread(
        thread_id=thread_id,
        vendor_name=None,
        product_name=None,
        current_offer=None,
        target_price=None,
        status=NegotiationStatus.PENDING_ANALYSIS,
        last_email_subject=payload.subject,
        last_email_body=payload.body_text,
    )
    session.add(negotiation)
    session.flush()

    inbound_log = EmailLog(
        negotiation_thread_id=negotiation.id,  # type: ignore[arg-type]
        direction=EmailDirection.INBOUND,
        subject=payload.subject,
        body=payload.body_text,
    )
    session.add(inbound_log)
    session.commit()

    initial_state = _build_initial_state(payload, thread_id)
    updated_state = _invoke_graph(initial_state, thread_id)

    draft_response = updated_state.get("draft_response")
    if draft_response is None:
        raise HTTPException(
            status_code=500,
            detail="Draft email was not generated by the negotiation agent.",
        )

    # Update database with latest extracted metadata for traceability.
    negotiation.vendor_name = updated_state.get("vendor_name")
    negotiation.product_name = updated_state.get("product_name")
    negotiation.current_offer = updated_state.get("current_offer")
    negotiation.target_price = updated_state.get("target_price")
    negotiation.status = NegotiationStatus.AWAITING_HUMAN_REVIEW
    negotiation.last_email_body = draft_response

    session.add(negotiation)
    session.commit()

    return {
        "thread_id": thread_id,
        "status": negotiation.status.value,
        "draft_response": draft_response,
    }


@app.post("/approve/{thread_id}")
def approve_thread(
    thread_id: str = Path(..., description="LangGraph thread identifier."),
    session: Session = Depends(get_session),
) -> Dict[str, Any]:
    """Approve a drafted email and resume the negotiation graph.

    HUMAN-IN-THE-LOOP BEHAVIOUR:
    ----------------------------
    - The graph is compiled with `interrupt_before=["human_review"]`.
    - `/webhook/email` runs the graph until it pauses before `human_review`.
    - This `/approve/{thread_id}` endpoint is the ONLY place where the graph
      is resumed for that `thread_id`. This ensures no email can be "sent"
      by the agent without an explicit human approval call.
    """
    try:
        statement = select(NegotiationThread).where(NegotiationThread.thread_id == thread_id)
        negotiation: Optional[NegotiationThread] = session.exec(statement).one_or_none()
    except NoResultFound:
        negotiation = None

    if negotiation is None:
        raise HTTPException(status_code=404, detail="Negotiation thread not found.")

    if negotiation.status != NegotiationStatus.AWAITING_HUMAN_REVIEW:
        raise HTTPException(
            status_code=400,
            detail=f"Negotiation thread is not awaiting human review (current status: {negotiation.status.value}).",
        )

    # Resume the graph from its paused checkpoint. Because we are using a
    # checkpointer keyed by `thread_id`, providing the config alone is
    # sufficient to continue from where `/webhook/email` left off.
    config: GraphConfig = {"configurable": {"thread_id": thread_id}}
    resumed_state: NegotiationState = graph_app.invoke(None, config=config)

    final_response = resumed_state.get("draft_response") or negotiation.last_email_body

    # For the MVP we mock the "send" operation by recording an outbound EmailLog
    # and updating the negotiation status. No actual email is dispatched here.
    outbound_log = EmailLog(
        negotiation_thread_id=negotiation.id,  # type: ignore[arg-type]
        direction=EmailDirection.OUTBOUND,
        subject=negotiation.last_email_subject or "Negotiation response",
        body=final_response or "",
    )
    session.add(outbound_log)

    negotiation.status = NegotiationStatus.SENT
    session.add(negotiation)
    session.commit()

    return {
        "thread_id": thread_id,
        "status": negotiation.status.value,
        "final_response": final_response,
    }

